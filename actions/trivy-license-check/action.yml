name: 'Trivy License Check'
description: 'Check licenses using Trivy with custom policy'

inputs:
  image_name:
    description: 'Docker image name to scan. If not provided, filesystem scan will be performed.'
    required: false
  scan_ref:
    description: 'Target to scan (image name or filesystem path). Default is current directory.'
    required: false
    default: '.'
  scan_type:
    description: 'Scan type: "image" or "fs". Default is "fs".'
    required: false
    default: 'fs'
  policy_repo:
    description: 'Policy repository (e.g., org/common-policies). If not provided, uses anyfld/vistra-pj.'
    required: false
  policy_path:
    description: 'Path to policy file within the policy repository.'
    required: false
    default: 'configs/policy/license.rego'

runs:
  using: 'composite'
  steps:
    - name: Checkout Policy Repository
      uses: actions/checkout@v4
      with:
        repository: ${{ inputs.policy_repo || 'anyfld/vistra-pj' }}
        path: policy

    - name: Set Policy Path
      id: set-policy-path
      run: |
        echo "path=policy/${{ inputs.policy_path }}" >> "$GITHUB_OUTPUT"
      shell: bash

    - name: Set Scan Target
      id: set-scan-target
      run: |
        if [ "${{ inputs.scan_type }}" = "image" ] && [ -n "${{ inputs.image_name }}" ]; then
          echo "target=${{ inputs.image_name }}" >> "$GITHUB_OUTPUT"
        else
          echo "target=${{ inputs.scan_ref }}" >> "$GITHUB_OUTPUT"
        fi
      shell: bash

    - name: Run Trivy License Check
      id: trivy-check
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: ${{ inputs.scan_type }}
        scan-ref: ${{ steps.set-scan-target.outputs.target }}
        scanners: 'license'
        ignore-policy: ${{ steps.set-policy-path.outputs.path }}
        format: 'sarif'
        output: 'trivy-results.sarif'
        exit-code: '1'
      continue-on-error: true

    - name: Install Trivy and jq
      if: github.event_name == 'pull_request'
      run: |
        if ! command -v jq &> /dev/null; then
          sudo apt-get update && sudo apt-get install -y jq
        fi
        if ! command -v trivy &> /dev/null; then
          VERSION=$(curl -s https://api.github.com/repos/aquasecurity/trivy/releases/latest | jq -r '.tag_name' | sed 's/v//')
          wget -qO - "https://github.com/aquasecurity/trivy/releases/download/v${VERSION}/trivy_${VERSION}_Linux-64bit.tar.gz" | tar -xz
          sudo mv trivy /usr/local/bin/
        fi
      shell: bash

    - name: Get Trivy License Results (JSON)
      id: trivy-json
      if: github.event_name == 'pull_request'
      run: |
        # Get all license information without policy filtering for comment display
        trivy ${{ inputs.scan_type }} \
          --scanners license \
          --format json \
          --output trivy-results.json \
          ${{ steps.set-scan-target.outputs.target }} || true
        if [ -f trivy-results.json ]; then
          echo "results_file=trivy-results.json" >> "$GITHUB_OUTPUT"
        fi
      shell: bash

    - name: Debug JSON Output
      if: github.event_name == 'pull_request' && steps.trivy-json.outputs.results_file != ''
      run: |
        if [ -f "${{ steps.trivy-json.outputs.results_file }}" ]; then
          echo "=== JSON file exists ==="
          echo "File size: $(wc -c < "${{ steps.trivy-json.outputs.results_file }}") bytes"
          echo "=== Results count ==="
          jq '.Results | length' "${{ steps.trivy-json.outputs.results_file }}" || true
          echo "=== Packages count ==="
          jq '[.Results[] | .Packages[]?] | length' "${{ steps.trivy-json.outputs.results_file }}" || true
          echo "=== Licenses array exists in Results ==="
          jq '[.Results[] | has("Licenses")]' "${{ steps.trivy-json.outputs.results_file }}" || true
          echo "=== Licenses count in Results ==="
          jq '[.Results[] | .Licenses[]?] | length' "${{ steps.trivy-json.outputs.results_file }}" || true
          echo "=== Sample license structure ==="
          jq '.Results[0].Licenses[0] // empty' "${{ steps.trivy-json.outputs.results_file }}" || true
          echo "=== Packages with Licenses field ==="
          jq '[.Results[] | .Packages[]? | select(has("Licenses"))] | length' "${{ steps.trivy-json.outputs.results_file }}" || true
        fi
      shell: bash

    - name: Format License Results for Comment
      id: format-comment
      if: github.event_name == 'pull_request' && steps.trivy-json.outputs.results_file != ''
      run: |
        if [ -f "${{ steps.trivy-json.outputs.results_file }}" ]; then
          # Extract license information from JSON and format as markdown table
          # Try multiple approaches to extract license information
          COMMENT=$(jq -r '
            def format_license_name(lic):
              if lic | type == "string" then lic
              elif lic | type == "object" then lic.Name // lic.name // "N/A"
              else "N/A"
              end;

            # Approach 1: Get licenses from Results[].Licenses[] array (most common structure)
            [.Results[]? | .Licenses[]?] as $licenses |
            [.Results[]? | .Packages[]?] as $packages |

            if ($licenses | length > 0) then
              # Group licenses by package name
              "## ğŸ“‹ ãƒ©ã‚¤ã‚»ãƒ³ã‚¹æƒ…å ±\n\n" +
              "<details>\n<summary>ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãƒ©ã‚¤ã‚»ãƒ³ã‚¹æƒ…å ±ã‚’è¡¨ç¤º</summary>\n\n" +
              "| ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸å | ãƒãƒ¼ã‚¸ãƒ§ãƒ³ | ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ |\n" +
              "|------------|----------|----------|\n" +
              (
                $packages | unique_by(.Name) |
                .[] |
                . as $pkg |
                ($licenses | map(select((.Package // .package // "") == ($pkg.Name // ""))) | map(format_license_name(.)) | unique) as $pkg_lics |
                if ($pkg_lics | length > 0) then
                  "| \($pkg.Name // "N/A") | \($pkg.Version // "N/A") | \($pkg_lics | join(", ")) |\n"
                else
                  empty
                end
              ) +
              "\n</details>"
            # Approach 2: Get licenses from Packages[].Licenses field
            elif [.Results[]? | .Packages[]? | select(.Licenses != null and (.Licenses | length > 0))] | length > 0 then
              "## ğŸ“‹ ãƒ©ã‚¤ã‚»ãƒ³ã‚¹æƒ…å ±\n\n" +
              "<details>\n<summary>ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãƒ©ã‚¤ã‚»ãƒ³ã‚¹æƒ…å ±ã‚’è¡¨ç¤º</summary>\n\n" +
              "| ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸å | ãƒãƒ¼ã‚¸ãƒ§ãƒ³ | ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ |\n" +
              "|------------|----------|----------|\n" +
              (
                .Results[]? | .Packages[]? |
                select(.Licenses != null and (.Licenses | length > 0)) |
                "| \(.Name // "N/A") | \(.Version // "N/A") | \(.Licenses | map(format_license_name(.)) | join(", ")) |\n"
              ) +
              "\n</details>"
            else
              "## ğŸ“‹ ãƒ©ã‚¤ã‚»ãƒ³ã‚¹æƒ…å ±\n\nãƒ©ã‚¤ã‚»ãƒ³ã‚¹æƒ…å ±ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚"
            end
          ' "${{ steps.trivy-json.outputs.results_file }}" 2>&1)

          # Check if comment is empty or contains error
          if [ -z "$COMMENT" ] || echo "$COMMENT" | grep -q "error\|Error\|parse error\|jq:"; then
            echo "Error parsing JSON or empty result"
            echo "Comment content: $COMMENT"
            COMMENT="## ğŸ“‹ ãƒ©ã‚¤ã‚»ãƒ³ã‚¹æƒ…å ±\n\nãƒ©ã‚¤ã‚»ãƒ³ã‚¹æƒ…å ±ã®å–å¾—ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚\n\n\`\`\`json\n$(head -c 2000 "${{ steps.trivy-json.outputs.results_file }}")\n\`\`\`"
          fi

          # Save to file for multiline output
          echo -e "$COMMENT" > license-comment.md
          echo "comment_file=license-comment.md" >> "$GITHUB_OUTPUT"
          echo "Comment file created, size: $(wc -c < license-comment.md) bytes"
        fi
      shell: bash

    - name: Add PR Comment with License Information
      if: github.event_name == 'pull_request' && steps.format-comment.outputs.comment_file != ''
      uses: mshick/add-pr-comment@b8f338c590a895d50bcbfa6c5859251edc8952fc
      with:
        message-path: ${{ steps.format-comment.outputs.comment_file }}
        message-id: trivy-license-check
        allow-repeats: true
